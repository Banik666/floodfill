#include "src/CircularBufferQueue/CircularBufferQueue.h"
#include <EEPROM.h>

#define sensor_On_Pin 17
int sensorValue[7];

#define rows 16
#define cols 16

#define linearise(row, col) row * cols + col
#define delineariseRow(location) location / cols
#define delineariseCol(location) location % cols

#define distance(loc1, loc2) abs(delineariseRow(loc1) - delineariseRow(loc2)) + abs(delineariseCol(loc1) - delineariseCol(loc2))
#define markWall(location, direction) floodArray[location].neighbours |= 1 << direction
#define wallExists(location, direction) bitRead(floodArray[location].neighbours, direction)

#define getNeighbourLocation(location, direction) (byte)((short)location + cellDirectionAddition[direction])
#define getNeighbourDistanceIfAccessible(location, direction) floodArray[getNeighbourLocation(location, direction)].flood
#define getNeighbourDistance(location, direction) wallExists(location, direction) ? 255 : getNeighbourDistanceIfAccessible(location, direction)

#define updateDirection(currentDirection, turn) *currentDirection = (*currentDirection + turn) % 4

#define north 0
#define east 1
#define south 2
#define west 3

#define rightTurn 1
#define uTurn 2
#define leftTurn 3

#define leftSensor 0
#define diagonalLeftSensor 1
#define centreSensor 2
#define diagonalRightSenson 3
#define rightSensor 4

#define wallThreshold 120

#ifndef cbi
#define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
#endif
#ifndef sbi
#define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
#endif

struct cell {
  byte flood;
  byte neighbours;
  byte visited;
};

cell floodArray[rows * cols];

byte startCell = 0;
byte startDir = north;
byte targetCells[4] = { 255, 240, 15, 0 };  // Customize as needed
byte currentCell, targetCell;
byte leftDir, currentDir, rightDir, nextLeftDir, nextDir, nextRightDir;
short cellDirectionAddition[4] = { -rows, 1, rows, -1 };
byte updateDirectionTurnAmount[4] = { 0, rightTurn, uTurn, leftTurn };
byte targetScoreFromDirection[4] = { 0, 1, 2, 1 };

byte readingCellLoc, readingCellDistance, readingCellScore, minNeighbourDistance, targetRelativeDirection, targetScore;
byte distanceFromTarget = 1;
byte resetMazeEEPROM = 1;

CircularBufferQueue floodQueue(512);

void setup() {
  Serial.begin(9600);
  sbi(ADCSRA, ADPS2);
  cbi(ADCSRA, ADPS1);
  cbi(ADCSRA, ADPS0);
  pinMode(sensor_On_Pin, OUTPUT);

  if (resetMazeEEPROM) resetMazeValuesInEEPROM();
  else updateMazeValuesFromEEPROM();

  calibrate();
}

void loop() {
  currentCell = startCell;
  initialiseDirections();
  while (currentCell != targetCells[0] && currentCell != targetCells[1] && currentCell != targetCells[2] && currentCell != targetCells[3]) {
    updateWalls();
    flood();
    updateTargetCell();
    goToTargetCell();
    currentCell = targetCell;
    floodArray[currentCell].visited = 1;
  }
  updateMazeValuesInEEPROM();
}

void flood() {
  floodQueue.enqueue(currentCell);
  while (!floodQueue.isEmpty()) {
    readingCellLoc = *floodQueue.dequeue();
    if (isEnclosed(readingCellLoc)) continue;
    readingCellDistance = floodArray[readingCellLoc].flood;
    minNeighbourDistance = 255;
    for (byte i = 0; i < 4; i++) {
      minNeighbourDistance = min(minNeighbourDistance, getNeighbourDistance(readingCellLoc, i));
    }
    if (minNeighbourDistance != readingCellDistance - 1) {
      floodArray[readingCellLoc].flood = minNeighbourDistance + 1;
      for (byte i = 0; i < 4; i++) {
        if (isNeighbourValid(readingCellLoc, i)) {
          if (!isDestination(getNeighbourLocation(readingCellLoc, i))) {
            floodQueue.enqueue(getNeighbourLocation(readingCellLoc, i));
          }
        }
      }
    }
  }
}

void updateTargetCell() {
  minNeighbourDistance = getNeighbourDistance(currentCell, 0);
  targetScore = 3;
  for (byte i = 0; i < 4; i++) {
    if (!wallExists(currentCell, i)) {
      readingCellLoc = getNeighbourLocation(currentCell, i);
      readingCellDistance = getNeighbourDistance(currentCell, i);
      readingCellScore = targetScoreFromDirection[getTargetRelativeDirection(readingCellLoc)];
      if ((readingCellDistance < minNeighbourDistance) || ((readingCellDistance == minNeighbourDistance) && (readingCellScore < targetScore))) {
        minNeighbourDistance = readingCellDistance;
        targetScore = readingCellScore;
        targetCell = readingCellLoc;
      }
    }
  }

  targetRelativeDirection = getTargetRelativeDirection(targetCell);
  updateDirection(&nextLeftDir, updateDirectionTurnAmount[targetRelativeDirection]);
  updateDirection(&nextDir, updateDirectionTurnAmount[targetRelativeDirection]);
  updateDirection(&nextRightDir, updateDirectionTurnAmount[targetRelativeDirection]);

  distanceFromTarget = 1;
  while (isNeighbourValid(targetCell, nextDir)) {
    readingCellLoc = getNeighbourLocation(targetCell, nextDir);
    if (isTunnel(readingCellLoc) && floodArray[readingCellLoc].flood == floodArray[targetCell].flood - 1) {
      targetCell = readingCellLoc;
      distanceFromTarget++;
    } else break;
  }
}

void goToTargetCell() {
  if (targetRelativeDirection == north) {
  } else if (targetRelativeDirection == east) {
    turn(90, 70);
  } else if (targetRelativeDirection == south) {
    turn(180, 70);
  } else if (targetRelativeDirection == west) {
    turn(-90, 70);
  }
  moveForward(distanceFromTarget, 100);
  updateDirection(&leftDir, updateDirectionTurnAmount[targetRelativeDirection]);
  updateDirection(&currentDir, updateDirectionTurnAmount[targetRelativeDirection]);
  updateDirection(&rightDir, updateDirectionTurnAmount[targetRelativeDirection]);
}

void updateWalls() {
  readWall();
  if (sensorValue[leftSensor] > wallThreshold) {
    markWall(currentCell, leftDir);
    if (isNeighbourValid(currentCell, leftDir)) markWall(getNeighbourLocation(currentCell, leftDir), (leftDir + 2) % 4);
  }
  if (sensorValue[centreSensor] > wallThreshold) {
    markWall(currentCell, currentDir);
    if (isNeighbourValid(currentCell, currentDir)) markWall(getNeighbourLocation(currentCell, currentDir), (currentDir + 2) % 4);
    alignFront();
  }
  if (sensorValue[rightSensor] > wallThreshold) {
    markWall(currentCell, rightDir);
    if (isNeighbourValid(currentCell, rightDir)) markWall(getNeighbourLocation(currentCell, rightDir), (rightDir + 2) % 4);
  }
}

bool isNeighbourValid(byte location, byte direction) {
  if (direction == north) return delineariseRow(location) > 0;
  else if (direction == east) return delineariseCol(location) < (cols - 1);
  else if (direction == south) return delineariseRow(location) < (rows - 1);
  else if (direction == west) return delineariseCol(location) > 0;
}

byte getTargetAbsoluteDirection(byte target) {
  short diff = (short)target - (short)currentCell;
  if (diff == -rows) return north;
  if (diff == 1) return east;
  if (diff == rows) return south;
  if (diff == -1) return west;
}

byte getTargetRelativeDirection(byte target) {
  return (getTargetAbsoluteDirection(target) + 4 - currentDir) % 4;
}

bool isDestination(byte location) {
  return floodArray[location].flood == 0;
}

bool isEnclosed(byte location) {
  return floodArray[location].neighbours == 15;
}

bool isTunnel(byte location) {
  return (!wallExists(location, nextDir)) && wallExists(location, nextLeftDir) && wallExists(location, nextRightDir) && floodArray[location].visited;
}

void initialiseDirections() {
  currentDir = startDir;
  leftDir = (currentDir + 3) % 4;
  rightDir = (currentDir + 1) % 4;
  nextLeftDir = leftDir;
  nextDir = currentDir;
  nextRightDir = rightDir;
}

void updateMazeValuesFromEEPROM() {
  for (byte i = 0; i < (rows * cols); i++) {
    floodArray[i].flood = EEPROM.read(i);
    floodArray[i].neighbours = EEPROM.read((rows * cols) + (short)i);
    floodArray[i].visited = EEPROM.read((2 * rows * cols) + (short)i);
  }
}

void updateMazeValuesInEEPROM() {
  for (byte i = 0; i < (rows * cols); i++) {
    EEPROM.write(i, floodArray[i].flood);
    EEPROM.write((rows * cols) + (short)i, floodArray[i].neighbours);
    EEPROM.write((2 * rows * cols) + (short)i, floodArray[i].visited);
  }
}

void resetMazeValuesInEEPROM() {
  for (byte i = 0; i < (rows * cols); i++) {
    floodArray[i].flood = 255;
    for (byte j = 0; j < 4; j++) floodArray[i].flood = min(floodArray[i].flood, distance(i, targetCells[j]));
    floodArray[i].neighbours = 0;
    floodArray[i].visited = 0;
    if (delineariseRow(i) == 0) markWall(i, north);
    if (delineariseCol(i) == 0) markWall(i, west);
    if (delineariseRow(i) == (rows - 1)) markWall(i, south);
    if (delineariseCol(i) == (cols - 1)) markWall(i, east);
  }
  updateMazeValuesInEEPROM();
}
